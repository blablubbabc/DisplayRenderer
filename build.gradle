plugins {
	id 'java-library'
	id 'maven-publish'
	id 'eclipse'
}

ext.getGitHash = { ->
	def stdout = new ByteArrayOutputStream()
	exec {
		commandLine 'git', 'rev-parse', '--short', 'HEAD'
		standardOutput = stdout
		ignoreExitValue = true // Non-zero exit value of there is not commit yet
	}
	return stdout.toString().trim()
}

// We embed the git hash into jar files, and also use it for the plugin version of snapshot builds.
ext.buildVersion = version + '+' + getGitHash()
ext.isSnapshot = version.contains('-SNAPSHOT')
ext.pluginVersion = isSnapshot ? buildVersion : version

println 'User home: ' + System.properties['user.home']
println 'Local Maven repository: ' + repositories.mavenLocal().url.path
println 'Locale: ' + Locale.getDefault()
println 'Project version: ' + version
println 'Build version: ' + buildVersion
println 'Plugin version: ' + pluginVersion

allprojects {
	// Set up default properties if they match the root project's values:
	// Note: In order to allow subprojects to define their values of these properties inside their
	// build files (instead of their 'gradle.properties' files), any task configurations that depend
	// on these properties have to be deferred until after the subproject's build script has been
	// evaluated.
	if (project.properties['artifactId'] == rootProject.properties['artifactId']) {
		project.ext.artifactId = project.name
	}
	afterEvaluate {
		if (project.artifactId != project.name) {
			println 'Artifact id: ' + project.artifactId
		}
	}
}

repositories {
	mavenLocal()
	mavenCentral()
	// Bukkit, Spigot-API
	maven { url 'https://hub.spigotmc.org/nexus/content/groups/public/' }
}

dependencies {
	// compileOnly: Omits these dependencies from the transitively inherited apiElements and
	// runtimeElements. However, we need to manually add these dependencies to our test dependencies
	// if needed.
	compileOnly libs.spigot.api // Includes the Bukkit API

	testImplementation libs.spigot.api
	testImplementation libs.junit
}

java {
	sourceCompatibility = JavaVersion.VERSION_21
}

// Configure all JavaCompile tasks (compileJava, compileTestJava, etc):
tasks.withType(JavaCompile) {
	options.encoding = 'UTF-8'
}

processResources {
	inputs.property 'pluginVersion', pluginVersion
	inputs.property 'dboUrl', dboUrl

	from rootProject.file('LICENSE')
	from project.sourceSets.main.resources.srcDirs
	// TODO Some plugins might add resource directories twice.
	// See https://github.com/gradle/gradle/issues/17236
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	filesMatching('plugin.yml') {
		expand([
			'pluginVersion': pluginVersion,
			'description': description,
			'dboUrl': dboUrl
		])
	}
}

jar {
	inputs.property 'group', project.group
	inputs.property 'artifactId', project.artifactId
	inputs.property 'buildVersion', project.buildVersion

	archiveBaseName = project.artifactId
	manifest {
		attributes 'Implementation-Title': "${project.group}:${project.artifactId}",
			'Implementation-Version': project.buildVersion
	}
}

test {
	systemProperty 'file.encoding', 'UTF-8'
	workingDir project.file("${project.buildDir}/test-work/")
	// Gradle complains when this folder does not yet exist.
	doFirst {
		workingDir.mkdirs()
	}
}
